---
description: 
globs: **/*.test.ts,**/*.test.tsx,**/*.spec.ts,**/test/**/*.ts
alwaysApply: false
---
# Testing with Vitest

## Vitest Configuration
- Use Vitest for all JavaScript/TypeScript testing
- Configure proper test environment (jsdom for React components)
- Set up path aliases matching the main project
- Use proper TypeScript configuration for tests

```tsx
// vitest.config.ts
import { defineConfig } from 'vitest/config'
import react from '@vitejs/plugin-react'
import path from 'path'

export default defineConfig({
  plugins: [react()],
  test: {
    environment: 'jsdom',
    setupFiles: ['./src/test/setup.ts'],
    globals: true,
    css: true,
  },
  resolve: {
    alias: {
      '@': path.resolve(__dirname, './src'),
      '@/components': path.resolve(__dirname, './src/components'),
      '@/lib': path.resolve(__dirname, './src/lib'),
    },
  },
})
```

## Test File Structure
- Place tests adjacent to source files with `.test.ts` or `.test.tsx` suffix
- Group related tests in `describe` blocks
- Use descriptive test names that explain the behavior being tested
- Follow AAA pattern: Arrange, Act, Assert

```tsx
// volunteer-service.test.ts
import { describe, it, expect, vi, beforeEach } from 'vitest'
import { registerVolunteer } from './volunteer-service'
import { createMockVolunteer } from '@/test/factories'

describe('VolunteerService', () => {
  describe('registerVolunteer', () => {
    it('should create volunteer with valid data', async () => {
      // Arrange
      const volunteerData = createMockVolunteer()
      
      // Act
      const result = await registerVolunteer(volunteerData)
      
      // Assert
      expect(result.success).toBe(true)
      expect(result.data.email).toBe(volunteerData.email)
    })

    it('should throw validation error for invalid email', async () => {
      // Arrange
      const invalidData = createMockVolunteer({ email: 'invalid-email' })
      
      // Act & Assert
      await expect(registerVolunteer(invalidData)).rejects.toThrow('Invalid email')
    })
  })
})
```

## React Component Testing
- Use React Testing Library for component tests
- Test user interactions, not implementation details
- Use accessible queries (getByRole, getByLabelText)
- Test error states and loading states

```tsx
// volunteer-card.test.tsx
import { render, screen, fireEvent } from '@testing-library/react'
import { describe, it, expect, vi } from 'vitest'
import { VolunteerCard } from './volunteer-card'
import { createMockVolunteer } from '@/test/factories'

describe('VolunteerCard', () => {
  it('displays volunteer information correctly', () => {
    // Arrange
    const volunteer = createMockVolunteer({
      name: 'John Doe',
      email: 'john@example.com',
      status: 'ACTIVE'
    })

    // Act
    render(<VolunteerCard volunteer={volunteer} />)

    // Assert
    expect(screen.getByText('John Doe')).toBeInTheDocument()
    expect(screen.getByText('john@example.com')).toBeInTheDocument()
    expect(screen.getByRole('status')).toHaveTextContent('ACTIVE')
  })

  it('calls onSelect when card is clicked', () => {
    // Arrange
    const volunteer = createMockVolunteer()
    const onSelect = vi.fn()

    // Act
    render(<VolunteerCard volunteer={volunteer} onSelect={onSelect} />)
    fireEvent.click(screen.getByRole('button'))

    // Assert
    expect(onSelect).toHaveBeenCalledWith(volunteer)
  })

  it('shows admin actions when showActions is true', () => {
    // Arrange
    const volunteer = createMockVolunteer()

    // Act
    render(<VolunteerCard volunteer={volunteer} showActions={true} />)

    // Assert
    expect(screen.getByRole('button', { name: /edit/i })).toBeInTheDocument()
    expect(screen.getByRole('button', { name: /delete/i })).toBeInTheDocument()
  })
})
```

## API Route Testing
- Test all API routes with proper HTTP methods
- Test authentication and authorization
- Test error handling and edge cases
- Use supertest or similar for integration testing

```tsx
// api/volunteers.test.ts
import { describe, it, expect, beforeEach, afterEach } from 'vitest'
import { createTestServer } from '@/test/server'
import { createMockVolunteer, createMockSession } from '@/test/factories'

describe('/api/volunteers', () => {
  let server: TestServer

  beforeEach(async () => {
    server = await createTestServer()
  })

  afterEach(async () => {
    await server.cleanup()
  })

  describe('POST /api/volunteers', () => {
    it('creates volunteer with valid data', async () => {
      // Arrange
      const volunteerData = createMockVolunteer()
      const session = createMockSession({ role: 'admin' })

      // Act
      const response = await server
        .post('/api/volunteers')
        .set('Authorization', `Bearer ${session.token}`)
        .send(volunteerData)

      // Assert
      expect(response.status).toBe(201)
      expect(response.body.success).toBe(true)
      expect(response.body.data.email).toBe(volunteerData.email)
    })

    it('returns 401 when unauthorized', async () => {
      // Arrange
      const volunteerData = createMockVolunteer()

      // Act
      const response = await server
        .post('/api/volunteers')
        .send(volunteerData)

      // Assert
      expect(response.status).toBe(401)
      expect(response.body.success).toBe(false)
    })

    it('returns validation error for invalid data', async () => {
      // Arrange
      const invalidData = { name: '', email: 'invalid' }
      const session = createMockSession({ role: 'admin' })

      // Act
      const response = await server
        .post('/api/volunteers')
        .set('Authorization', `Bearer ${session.token}`)
        .send(invalidData)

      // Assert
      expect(response.status).toBe(400)
      expect(response.body.success).toBe(false)
      expect(response.body.details).toBeDefined()
    })
  })
})
```

## Mocking Strategies
- Use Vitest's built-in mocking capabilities
- Mock external dependencies and APIs
- Create factory functions for test data
- Use MSW for mocking HTTP requests

```tsx
// test/factories.ts
import { faker } from '@faker-js/faker'
import type { Volunteer, Shift } from '@/types'

export function createMockVolunteer(overrides: Partial<Volunteer> = {}): Volunteer {
  return {
    id: faker.string.uuid(),
    name: faker.person.fullName(),
    email: faker.internet.email(),
    phone: faker.phone.number(),
    status: 'ACTIVE',
    createdAt: new Date(),
    updatedAt: new Date(),
    ...overrides,
  }
}

export function createMockShift(overrides: Partial<Shift> = {}): Shift {
  return {
    id: faker.string.uuid(),
    title: faker.lorem.words(3),
    startTime: faker.date.future(),
    endTime: faker.date.future(),
    capacity: faker.number.int({ min: 1, max: 10 }),
    volunteersAssigned: 0,
    ...overrides,
  }
}

// Mocking external services
vi.mock('@/lib/email-service', () => ({
  sendWelcomeEmail: vi.fn().mockResolvedValue({ success: true }),
  sendShiftReminder: vi.fn().mockResolvedValue({ success: true }),
}))
```

## Database Testing
- Use test database or in-memory database
- Clean up data between tests
- Test database operations and constraints
- Mock Prisma client for unit tests

```tsx
// test/db-setup.ts
import { PrismaClient } from '@prisma/client'
import { beforeEach, afterEach } from 'vitest'

const prisma = new PrismaClient({
  datasources: {
    db: {
      url: process.env.TEST_DATABASE_URL,
    },
  },
})

beforeEach(async () => {
  // Clean up database before each test
  await prisma.volunteer.deleteMany()
  await prisma.shift.deleteMany()
})

afterEach(async () => {
  // Additional cleanup if needed
})

export { prisma }
```

## Test Coverage
- Aim for 80%+ code coverage
- Focus on critical business logic
- Test error paths and edge cases
- Use coverage reports to identify gaps

```json
// package.json test scripts
{
  "scripts": {
    "test": "vitest",
    "test:ui": "vitest --ui",
    "test:run": "vitest run",
    "test:coverage": "vitest run --coverage",
    "test:watch": "vitest --watch"
  }
}
```

## Testing Best Practices
- Write tests before or during development (TDD/BDD)
- Keep tests simple and focused on one behavior
- Use descriptive test names that explain the scenario
- Avoid testing implementation details
- Test the happy path and error cases
- Use setup and teardown properly
- Make tests independent and deterministic

## Performance Testing
- Test API response times for critical endpoints
- Test component render performance
- Use Vitest benchmarks for performance-critical functions
- Monitor memory usage in long-running tests

```tsx
// performance.test.ts
import { bench, describe } from 'vitest'
import { calculateVolunteerHours } from './volunteer-utils'
import { createMockVolunteer } from '@/test/factories'

describe('Performance Tests', () => {
  bench('calculateVolunteerHours with 1000 volunteers', () => {
    const volunteers = Array.from({ length: 1000 }, () => createMockVolunteer())
    calculateVolunteerHours(volunteers)
  })
})
```

## CI/CD Integration
- Run tests on every pull request
- Fail builds on test failures
- Generate and publish coverage reports
- Use parallel test execution for faster feedback

## Test Documentation
- Document test setup and configuration
- Explain complex test scenarios
- Maintain test data factories and utilities
- Document browser/environment requirements for E2E tests
