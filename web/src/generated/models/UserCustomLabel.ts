
/* !!! This is code generated by Prisma. Do not edit directly. !!! */
/* eslint-disable */
// biome-ignore-all lint: generated file
// @ts-nocheck 
/*
 * This file exports the `UserCustomLabel` model and its related types.
 *
 * ðŸŸ¢ You can import this file directly.
 */
import type * as runtime from "@prisma/client/runtime/client"
import type * as $Enums from "../enums"
import type * as Prisma from "../internal/prismaNamespace"

/**
 * Model UserCustomLabel
 * 
 */
export type UserCustomLabelModel = runtime.Types.Result.DefaultSelection<Prisma.$UserCustomLabelPayload>

export type AggregateUserCustomLabel = {
  _count: UserCustomLabelCountAggregateOutputType | null
  _min: UserCustomLabelMinAggregateOutputType | null
  _max: UserCustomLabelMaxAggregateOutputType | null
}

export type UserCustomLabelMinAggregateOutputType = {
  id: string | null
  userId: string | null
  labelId: string | null
  assignedAt: Date | null
}

export type UserCustomLabelMaxAggregateOutputType = {
  id: string | null
  userId: string | null
  labelId: string | null
  assignedAt: Date | null
}

export type UserCustomLabelCountAggregateOutputType = {
  id: number
  userId: number
  labelId: number
  assignedAt: number
  _all: number
}


export type UserCustomLabelMinAggregateInputType = {
  id?: true
  userId?: true
  labelId?: true
  assignedAt?: true
}

export type UserCustomLabelMaxAggregateInputType = {
  id?: true
  userId?: true
  labelId?: true
  assignedAt?: true
}

export type UserCustomLabelCountAggregateInputType = {
  id?: true
  userId?: true
  labelId?: true
  assignedAt?: true
  _all?: true
}

export type UserCustomLabelAggregateArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Filter which UserCustomLabel to aggregate.
   */
  where?: Prisma.UserCustomLabelWhereInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
   * 
   * Determine the order of UserCustomLabels to fetch.
   */
  orderBy?: Prisma.UserCustomLabelOrderByWithRelationInput | Prisma.UserCustomLabelOrderByWithRelationInput[]
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
   * 
   * Sets the start position
   */
  cursor?: Prisma.UserCustomLabelWhereUniqueInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Take `Â±n` UserCustomLabels from the position of the cursor.
   */
  take?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Skip the first `n` UserCustomLabels.
   */
  skip?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
   * 
   * Count returned UserCustomLabels
  **/
  _count?: true | UserCustomLabelCountAggregateInputType
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
   * 
   * Select which fields to find the minimum value
  **/
  _min?: UserCustomLabelMinAggregateInputType
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
   * 
   * Select which fields to find the maximum value
  **/
  _max?: UserCustomLabelMaxAggregateInputType
}

export type GetUserCustomLabelAggregateType<T extends UserCustomLabelAggregateArgs> = {
      [P in keyof T & keyof AggregateUserCustomLabel]: P extends '_count' | 'count'
    ? T[P] extends true
      ? number
      : Prisma.GetScalarType<T[P], AggregateUserCustomLabel[P]>
    : Prisma.GetScalarType<T[P], AggregateUserCustomLabel[P]>
}




export type UserCustomLabelGroupByArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  where?: Prisma.UserCustomLabelWhereInput
  orderBy?: Prisma.UserCustomLabelOrderByWithAggregationInput | Prisma.UserCustomLabelOrderByWithAggregationInput[]
  by: Prisma.UserCustomLabelScalarFieldEnum[] | Prisma.UserCustomLabelScalarFieldEnum
  having?: Prisma.UserCustomLabelScalarWhereWithAggregatesInput
  take?: number
  skip?: number
  _count?: UserCustomLabelCountAggregateInputType | true
  _min?: UserCustomLabelMinAggregateInputType
  _max?: UserCustomLabelMaxAggregateInputType
}

export type UserCustomLabelGroupByOutputType = {
  id: string
  userId: string
  labelId: string
  assignedAt: Date
  _count: UserCustomLabelCountAggregateOutputType | null
  _min: UserCustomLabelMinAggregateOutputType | null
  _max: UserCustomLabelMaxAggregateOutputType | null
}

type GetUserCustomLabelGroupByPayload<T extends UserCustomLabelGroupByArgs> = Prisma.PrismaPromise<
  Array<
    Prisma.PickEnumerable<UserCustomLabelGroupByOutputType, T['by']> &
      {
        [P in ((keyof T) & (keyof UserCustomLabelGroupByOutputType))]: P extends '_count'
          ? T[P] extends boolean
            ? number
            : Prisma.GetScalarType<T[P], UserCustomLabelGroupByOutputType[P]>
          : Prisma.GetScalarType<T[P], UserCustomLabelGroupByOutputType[P]>
      }
    >
  >



export type UserCustomLabelWhereInput = {
  AND?: Prisma.UserCustomLabelWhereInput | Prisma.UserCustomLabelWhereInput[]
  OR?: Prisma.UserCustomLabelWhereInput[]
  NOT?: Prisma.UserCustomLabelWhereInput | Prisma.UserCustomLabelWhereInput[]
  id?: Prisma.StringFilter<"UserCustomLabel"> | string
  userId?: Prisma.StringFilter<"UserCustomLabel"> | string
  labelId?: Prisma.StringFilter<"UserCustomLabel"> | string
  assignedAt?: Prisma.DateTimeFilter<"UserCustomLabel"> | Date | string
  user?: Prisma.XOR<Prisma.UserScalarRelationFilter, Prisma.UserWhereInput>
  label?: Prisma.XOR<Prisma.CustomLabelScalarRelationFilter, Prisma.CustomLabelWhereInput>
}

export type UserCustomLabelOrderByWithRelationInput = {
  id?: Prisma.SortOrder
  userId?: Prisma.SortOrder
  labelId?: Prisma.SortOrder
  assignedAt?: Prisma.SortOrder
  user?: Prisma.UserOrderByWithRelationInput
  label?: Prisma.CustomLabelOrderByWithRelationInput
}

export type UserCustomLabelWhereUniqueInput = Prisma.AtLeast<{
  id?: string
  userId_labelId?: Prisma.UserCustomLabelUserIdLabelIdCompoundUniqueInput
  AND?: Prisma.UserCustomLabelWhereInput | Prisma.UserCustomLabelWhereInput[]
  OR?: Prisma.UserCustomLabelWhereInput[]
  NOT?: Prisma.UserCustomLabelWhereInput | Prisma.UserCustomLabelWhereInput[]
  userId?: Prisma.StringFilter<"UserCustomLabel"> | string
  labelId?: Prisma.StringFilter<"UserCustomLabel"> | string
  assignedAt?: Prisma.DateTimeFilter<"UserCustomLabel"> | Date | string
  user?: Prisma.XOR<Prisma.UserScalarRelationFilter, Prisma.UserWhereInput>
  label?: Prisma.XOR<Prisma.CustomLabelScalarRelationFilter, Prisma.CustomLabelWhereInput>
}, "id" | "userId_labelId">

export type UserCustomLabelOrderByWithAggregationInput = {
  id?: Prisma.SortOrder
  userId?: Prisma.SortOrder
  labelId?: Prisma.SortOrder
  assignedAt?: Prisma.SortOrder
  _count?: Prisma.UserCustomLabelCountOrderByAggregateInput
  _max?: Prisma.UserCustomLabelMaxOrderByAggregateInput
  _min?: Prisma.UserCustomLabelMinOrderByAggregateInput
}

export type UserCustomLabelScalarWhereWithAggregatesInput = {
  AND?: Prisma.UserCustomLabelScalarWhereWithAggregatesInput | Prisma.UserCustomLabelScalarWhereWithAggregatesInput[]
  OR?: Prisma.UserCustomLabelScalarWhereWithAggregatesInput[]
  NOT?: Prisma.UserCustomLabelScalarWhereWithAggregatesInput | Prisma.UserCustomLabelScalarWhereWithAggregatesInput[]
  id?: Prisma.StringWithAggregatesFilter<"UserCustomLabel"> | string
  userId?: Prisma.StringWithAggregatesFilter<"UserCustomLabel"> | string
  labelId?: Prisma.StringWithAggregatesFilter<"UserCustomLabel"> | string
  assignedAt?: Prisma.DateTimeWithAggregatesFilter<"UserCustomLabel"> | Date | string
}

export type UserCustomLabelCreateInput = {
  id?: string
  assignedAt?: Date | string
  user: Prisma.UserCreateNestedOneWithoutCustomLabelsInput
  label: Prisma.CustomLabelCreateNestedOneWithoutUsersInput
}

export type UserCustomLabelUncheckedCreateInput = {
  id?: string
  userId: string
  labelId: string
  assignedAt?: Date | string
}

export type UserCustomLabelUpdateInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  assignedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  user?: Prisma.UserUpdateOneRequiredWithoutCustomLabelsNestedInput
  label?: Prisma.CustomLabelUpdateOneRequiredWithoutUsersNestedInput
}

export type UserCustomLabelUncheckedUpdateInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  userId?: Prisma.StringFieldUpdateOperationsInput | string
  labelId?: Prisma.StringFieldUpdateOperationsInput | string
  assignedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
}

export type UserCustomLabelCreateManyInput = {
  id?: string
  userId: string
  labelId: string
  assignedAt?: Date | string
}

export type UserCustomLabelUpdateManyMutationInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  assignedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
}

export type UserCustomLabelUncheckedUpdateManyInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  userId?: Prisma.StringFieldUpdateOperationsInput | string
  labelId?: Prisma.StringFieldUpdateOperationsInput | string
  assignedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
}

export type UserCustomLabelListRelationFilter = {
  every?: Prisma.UserCustomLabelWhereInput
  some?: Prisma.UserCustomLabelWhereInput
  none?: Prisma.UserCustomLabelWhereInput
}

export type UserCustomLabelOrderByRelationAggregateInput = {
  _count?: Prisma.SortOrder
}

export type UserCustomLabelUserIdLabelIdCompoundUniqueInput = {
  userId: string
  labelId: string
}

export type UserCustomLabelCountOrderByAggregateInput = {
  id?: Prisma.SortOrder
  userId?: Prisma.SortOrder
  labelId?: Prisma.SortOrder
  assignedAt?: Prisma.SortOrder
}

export type UserCustomLabelMaxOrderByAggregateInput = {
  id?: Prisma.SortOrder
  userId?: Prisma.SortOrder
  labelId?: Prisma.SortOrder
  assignedAt?: Prisma.SortOrder
}

export type UserCustomLabelMinOrderByAggregateInput = {
  id?: Prisma.SortOrder
  userId?: Prisma.SortOrder
  labelId?: Prisma.SortOrder
  assignedAt?: Prisma.SortOrder
}

export type UserCustomLabelCreateNestedManyWithoutUserInput = {
  create?: Prisma.XOR<Prisma.UserCustomLabelCreateWithoutUserInput, Prisma.UserCustomLabelUncheckedCreateWithoutUserInput> | Prisma.UserCustomLabelCreateWithoutUserInput[] | Prisma.UserCustomLabelUncheckedCreateWithoutUserInput[]
  connectOrCreate?: Prisma.UserCustomLabelCreateOrConnectWithoutUserInput | Prisma.UserCustomLabelCreateOrConnectWithoutUserInput[]
  createMany?: Prisma.UserCustomLabelCreateManyUserInputEnvelope
  connect?: Prisma.UserCustomLabelWhereUniqueInput | Prisma.UserCustomLabelWhereUniqueInput[]
}

export type UserCustomLabelUncheckedCreateNestedManyWithoutUserInput = {
  create?: Prisma.XOR<Prisma.UserCustomLabelCreateWithoutUserInput, Prisma.UserCustomLabelUncheckedCreateWithoutUserInput> | Prisma.UserCustomLabelCreateWithoutUserInput[] | Prisma.UserCustomLabelUncheckedCreateWithoutUserInput[]
  connectOrCreate?: Prisma.UserCustomLabelCreateOrConnectWithoutUserInput | Prisma.UserCustomLabelCreateOrConnectWithoutUserInput[]
  createMany?: Prisma.UserCustomLabelCreateManyUserInputEnvelope
  connect?: Prisma.UserCustomLabelWhereUniqueInput | Prisma.UserCustomLabelWhereUniqueInput[]
}

export type UserCustomLabelUpdateManyWithoutUserNestedInput = {
  create?: Prisma.XOR<Prisma.UserCustomLabelCreateWithoutUserInput, Prisma.UserCustomLabelUncheckedCreateWithoutUserInput> | Prisma.UserCustomLabelCreateWithoutUserInput[] | Prisma.UserCustomLabelUncheckedCreateWithoutUserInput[]
  connectOrCreate?: Prisma.UserCustomLabelCreateOrConnectWithoutUserInput | Prisma.UserCustomLabelCreateOrConnectWithoutUserInput[]
  upsert?: Prisma.UserCustomLabelUpsertWithWhereUniqueWithoutUserInput | Prisma.UserCustomLabelUpsertWithWhereUniqueWithoutUserInput[]
  createMany?: Prisma.UserCustomLabelCreateManyUserInputEnvelope
  set?: Prisma.UserCustomLabelWhereUniqueInput | Prisma.UserCustomLabelWhereUniqueInput[]
  disconnect?: Prisma.UserCustomLabelWhereUniqueInput | Prisma.UserCustomLabelWhereUniqueInput[]
  delete?: Prisma.UserCustomLabelWhereUniqueInput | Prisma.UserCustomLabelWhereUniqueInput[]
  connect?: Prisma.UserCustomLabelWhereUniqueInput | Prisma.UserCustomLabelWhereUniqueInput[]
  update?: Prisma.UserCustomLabelUpdateWithWhereUniqueWithoutUserInput | Prisma.UserCustomLabelUpdateWithWhereUniqueWithoutUserInput[]
  updateMany?: Prisma.UserCustomLabelUpdateManyWithWhereWithoutUserInput | Prisma.UserCustomLabelUpdateManyWithWhereWithoutUserInput[]
  deleteMany?: Prisma.UserCustomLabelScalarWhereInput | Prisma.UserCustomLabelScalarWhereInput[]
}

export type UserCustomLabelUncheckedUpdateManyWithoutUserNestedInput = {
  create?: Prisma.XOR<Prisma.UserCustomLabelCreateWithoutUserInput, Prisma.UserCustomLabelUncheckedCreateWithoutUserInput> | Prisma.UserCustomLabelCreateWithoutUserInput[] | Prisma.UserCustomLabelUncheckedCreateWithoutUserInput[]
  connectOrCreate?: Prisma.UserCustomLabelCreateOrConnectWithoutUserInput | Prisma.UserCustomLabelCreateOrConnectWithoutUserInput[]
  upsert?: Prisma.UserCustomLabelUpsertWithWhereUniqueWithoutUserInput | Prisma.UserCustomLabelUpsertWithWhereUniqueWithoutUserInput[]
  createMany?: Prisma.UserCustomLabelCreateManyUserInputEnvelope
  set?: Prisma.UserCustomLabelWhereUniqueInput | Prisma.UserCustomLabelWhereUniqueInput[]
  disconnect?: Prisma.UserCustomLabelWhereUniqueInput | Prisma.UserCustomLabelWhereUniqueInput[]
  delete?: Prisma.UserCustomLabelWhereUniqueInput | Prisma.UserCustomLabelWhereUniqueInput[]
  connect?: Prisma.UserCustomLabelWhereUniqueInput | Prisma.UserCustomLabelWhereUniqueInput[]
  update?: Prisma.UserCustomLabelUpdateWithWhereUniqueWithoutUserInput | Prisma.UserCustomLabelUpdateWithWhereUniqueWithoutUserInput[]
  updateMany?: Prisma.UserCustomLabelUpdateManyWithWhereWithoutUserInput | Prisma.UserCustomLabelUpdateManyWithWhereWithoutUserInput[]
  deleteMany?: Prisma.UserCustomLabelScalarWhereInput | Prisma.UserCustomLabelScalarWhereInput[]
}

export type UserCustomLabelCreateNestedManyWithoutLabelInput = {
  create?: Prisma.XOR<Prisma.UserCustomLabelCreateWithoutLabelInput, Prisma.UserCustomLabelUncheckedCreateWithoutLabelInput> | Prisma.UserCustomLabelCreateWithoutLabelInput[] | Prisma.UserCustomLabelUncheckedCreateWithoutLabelInput[]
  connectOrCreate?: Prisma.UserCustomLabelCreateOrConnectWithoutLabelInput | Prisma.UserCustomLabelCreateOrConnectWithoutLabelInput[]
  createMany?: Prisma.UserCustomLabelCreateManyLabelInputEnvelope
  connect?: Prisma.UserCustomLabelWhereUniqueInput | Prisma.UserCustomLabelWhereUniqueInput[]
}

export type UserCustomLabelUncheckedCreateNestedManyWithoutLabelInput = {
  create?: Prisma.XOR<Prisma.UserCustomLabelCreateWithoutLabelInput, Prisma.UserCustomLabelUncheckedCreateWithoutLabelInput> | Prisma.UserCustomLabelCreateWithoutLabelInput[] | Prisma.UserCustomLabelUncheckedCreateWithoutLabelInput[]
  connectOrCreate?: Prisma.UserCustomLabelCreateOrConnectWithoutLabelInput | Prisma.UserCustomLabelCreateOrConnectWithoutLabelInput[]
  createMany?: Prisma.UserCustomLabelCreateManyLabelInputEnvelope
  connect?: Prisma.UserCustomLabelWhereUniqueInput | Prisma.UserCustomLabelWhereUniqueInput[]
}

export type UserCustomLabelUpdateManyWithoutLabelNestedInput = {
  create?: Prisma.XOR<Prisma.UserCustomLabelCreateWithoutLabelInput, Prisma.UserCustomLabelUncheckedCreateWithoutLabelInput> | Prisma.UserCustomLabelCreateWithoutLabelInput[] | Prisma.UserCustomLabelUncheckedCreateWithoutLabelInput[]
  connectOrCreate?: Prisma.UserCustomLabelCreateOrConnectWithoutLabelInput | Prisma.UserCustomLabelCreateOrConnectWithoutLabelInput[]
  upsert?: Prisma.UserCustomLabelUpsertWithWhereUniqueWithoutLabelInput | Prisma.UserCustomLabelUpsertWithWhereUniqueWithoutLabelInput[]
  createMany?: Prisma.UserCustomLabelCreateManyLabelInputEnvelope
  set?: Prisma.UserCustomLabelWhereUniqueInput | Prisma.UserCustomLabelWhereUniqueInput[]
  disconnect?: Prisma.UserCustomLabelWhereUniqueInput | Prisma.UserCustomLabelWhereUniqueInput[]
  delete?: Prisma.UserCustomLabelWhereUniqueInput | Prisma.UserCustomLabelWhereUniqueInput[]
  connect?: Prisma.UserCustomLabelWhereUniqueInput | Prisma.UserCustomLabelWhereUniqueInput[]
  update?: Prisma.UserCustomLabelUpdateWithWhereUniqueWithoutLabelInput | Prisma.UserCustomLabelUpdateWithWhereUniqueWithoutLabelInput[]
  updateMany?: Prisma.UserCustomLabelUpdateManyWithWhereWithoutLabelInput | Prisma.UserCustomLabelUpdateManyWithWhereWithoutLabelInput[]
  deleteMany?: Prisma.UserCustomLabelScalarWhereInput | Prisma.UserCustomLabelScalarWhereInput[]
}

export type UserCustomLabelUncheckedUpdateManyWithoutLabelNestedInput = {
  create?: Prisma.XOR<Prisma.UserCustomLabelCreateWithoutLabelInput, Prisma.UserCustomLabelUncheckedCreateWithoutLabelInput> | Prisma.UserCustomLabelCreateWithoutLabelInput[] | Prisma.UserCustomLabelUncheckedCreateWithoutLabelInput[]
  connectOrCreate?: Prisma.UserCustomLabelCreateOrConnectWithoutLabelInput | Prisma.UserCustomLabelCreateOrConnectWithoutLabelInput[]
  upsert?: Prisma.UserCustomLabelUpsertWithWhereUniqueWithoutLabelInput | Prisma.UserCustomLabelUpsertWithWhereUniqueWithoutLabelInput[]
  createMany?: Prisma.UserCustomLabelCreateManyLabelInputEnvelope
  set?: Prisma.UserCustomLabelWhereUniqueInput | Prisma.UserCustomLabelWhereUniqueInput[]
  disconnect?: Prisma.UserCustomLabelWhereUniqueInput | Prisma.UserCustomLabelWhereUniqueInput[]
  delete?: Prisma.UserCustomLabelWhereUniqueInput | Prisma.UserCustomLabelWhereUniqueInput[]
  connect?: Prisma.UserCustomLabelWhereUniqueInput | Prisma.UserCustomLabelWhereUniqueInput[]
  update?: Prisma.UserCustomLabelUpdateWithWhereUniqueWithoutLabelInput | Prisma.UserCustomLabelUpdateWithWhereUniqueWithoutLabelInput[]
  updateMany?: Prisma.UserCustomLabelUpdateManyWithWhereWithoutLabelInput | Prisma.UserCustomLabelUpdateManyWithWhereWithoutLabelInput[]
  deleteMany?: Prisma.UserCustomLabelScalarWhereInput | Prisma.UserCustomLabelScalarWhereInput[]
}

export type UserCustomLabelCreateWithoutUserInput = {
  id?: string
  assignedAt?: Date | string
  label: Prisma.CustomLabelCreateNestedOneWithoutUsersInput
}

export type UserCustomLabelUncheckedCreateWithoutUserInput = {
  id?: string
  labelId: string
  assignedAt?: Date | string
}

export type UserCustomLabelCreateOrConnectWithoutUserInput = {
  where: Prisma.UserCustomLabelWhereUniqueInput
  create: Prisma.XOR<Prisma.UserCustomLabelCreateWithoutUserInput, Prisma.UserCustomLabelUncheckedCreateWithoutUserInput>
}

export type UserCustomLabelCreateManyUserInputEnvelope = {
  data: Prisma.UserCustomLabelCreateManyUserInput | Prisma.UserCustomLabelCreateManyUserInput[]
  skipDuplicates?: boolean
}

export type UserCustomLabelUpsertWithWhereUniqueWithoutUserInput = {
  where: Prisma.UserCustomLabelWhereUniqueInput
  update: Prisma.XOR<Prisma.UserCustomLabelUpdateWithoutUserInput, Prisma.UserCustomLabelUncheckedUpdateWithoutUserInput>
  create: Prisma.XOR<Prisma.UserCustomLabelCreateWithoutUserInput, Prisma.UserCustomLabelUncheckedCreateWithoutUserInput>
}

export type UserCustomLabelUpdateWithWhereUniqueWithoutUserInput = {
  where: Prisma.UserCustomLabelWhereUniqueInput
  data: Prisma.XOR<Prisma.UserCustomLabelUpdateWithoutUserInput, Prisma.UserCustomLabelUncheckedUpdateWithoutUserInput>
}

export type UserCustomLabelUpdateManyWithWhereWithoutUserInput = {
  where: Prisma.UserCustomLabelScalarWhereInput
  data: Prisma.XOR<Prisma.UserCustomLabelUpdateManyMutationInput, Prisma.UserCustomLabelUncheckedUpdateManyWithoutUserInput>
}

export type UserCustomLabelScalarWhereInput = {
  AND?: Prisma.UserCustomLabelScalarWhereInput | Prisma.UserCustomLabelScalarWhereInput[]
  OR?: Prisma.UserCustomLabelScalarWhereInput[]
  NOT?: Prisma.UserCustomLabelScalarWhereInput | Prisma.UserCustomLabelScalarWhereInput[]
  id?: Prisma.StringFilter<"UserCustomLabel"> | string
  userId?: Prisma.StringFilter<"UserCustomLabel"> | string
  labelId?: Prisma.StringFilter<"UserCustomLabel"> | string
  assignedAt?: Prisma.DateTimeFilter<"UserCustomLabel"> | Date | string
}

export type UserCustomLabelCreateWithoutLabelInput = {
  id?: string
  assignedAt?: Date | string
  user: Prisma.UserCreateNestedOneWithoutCustomLabelsInput
}

export type UserCustomLabelUncheckedCreateWithoutLabelInput = {
  id?: string
  userId: string
  assignedAt?: Date | string
}

export type UserCustomLabelCreateOrConnectWithoutLabelInput = {
  where: Prisma.UserCustomLabelWhereUniqueInput
  create: Prisma.XOR<Prisma.UserCustomLabelCreateWithoutLabelInput, Prisma.UserCustomLabelUncheckedCreateWithoutLabelInput>
}

export type UserCustomLabelCreateManyLabelInputEnvelope = {
  data: Prisma.UserCustomLabelCreateManyLabelInput | Prisma.UserCustomLabelCreateManyLabelInput[]
  skipDuplicates?: boolean
}

export type UserCustomLabelUpsertWithWhereUniqueWithoutLabelInput = {
  where: Prisma.UserCustomLabelWhereUniqueInput
  update: Prisma.XOR<Prisma.UserCustomLabelUpdateWithoutLabelInput, Prisma.UserCustomLabelUncheckedUpdateWithoutLabelInput>
  create: Prisma.XOR<Prisma.UserCustomLabelCreateWithoutLabelInput, Prisma.UserCustomLabelUncheckedCreateWithoutLabelInput>
}

export type UserCustomLabelUpdateWithWhereUniqueWithoutLabelInput = {
  where: Prisma.UserCustomLabelWhereUniqueInput
  data: Prisma.XOR<Prisma.UserCustomLabelUpdateWithoutLabelInput, Prisma.UserCustomLabelUncheckedUpdateWithoutLabelInput>
}

export type UserCustomLabelUpdateManyWithWhereWithoutLabelInput = {
  where: Prisma.UserCustomLabelScalarWhereInput
  data: Prisma.XOR<Prisma.UserCustomLabelUpdateManyMutationInput, Prisma.UserCustomLabelUncheckedUpdateManyWithoutLabelInput>
}

export type UserCustomLabelCreateManyUserInput = {
  id?: string
  labelId: string
  assignedAt?: Date | string
}

export type UserCustomLabelUpdateWithoutUserInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  assignedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  label?: Prisma.CustomLabelUpdateOneRequiredWithoutUsersNestedInput
}

export type UserCustomLabelUncheckedUpdateWithoutUserInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  labelId?: Prisma.StringFieldUpdateOperationsInput | string
  assignedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
}

export type UserCustomLabelUncheckedUpdateManyWithoutUserInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  labelId?: Prisma.StringFieldUpdateOperationsInput | string
  assignedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
}

export type UserCustomLabelCreateManyLabelInput = {
  id?: string
  userId: string
  assignedAt?: Date | string
}

export type UserCustomLabelUpdateWithoutLabelInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  assignedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  user?: Prisma.UserUpdateOneRequiredWithoutCustomLabelsNestedInput
}

export type UserCustomLabelUncheckedUpdateWithoutLabelInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  userId?: Prisma.StringFieldUpdateOperationsInput | string
  assignedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
}

export type UserCustomLabelUncheckedUpdateManyWithoutLabelInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  userId?: Prisma.StringFieldUpdateOperationsInput | string
  assignedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
}



export type UserCustomLabelSelect<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = runtime.Types.Extensions.GetSelect<{
  id?: boolean
  userId?: boolean
  labelId?: boolean
  assignedAt?: boolean
  user?: boolean | Prisma.UserDefaultArgs<ExtArgs>
  label?: boolean | Prisma.CustomLabelDefaultArgs<ExtArgs>
}, ExtArgs["result"]["userCustomLabel"]>

export type UserCustomLabelSelectCreateManyAndReturn<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = runtime.Types.Extensions.GetSelect<{
  id?: boolean
  userId?: boolean
  labelId?: boolean
  assignedAt?: boolean
  user?: boolean | Prisma.UserDefaultArgs<ExtArgs>
  label?: boolean | Prisma.CustomLabelDefaultArgs<ExtArgs>
}, ExtArgs["result"]["userCustomLabel"]>

export type UserCustomLabelSelectUpdateManyAndReturn<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = runtime.Types.Extensions.GetSelect<{
  id?: boolean
  userId?: boolean
  labelId?: boolean
  assignedAt?: boolean
  user?: boolean | Prisma.UserDefaultArgs<ExtArgs>
  label?: boolean | Prisma.CustomLabelDefaultArgs<ExtArgs>
}, ExtArgs["result"]["userCustomLabel"]>

export type UserCustomLabelSelectScalar = {
  id?: boolean
  userId?: boolean
  labelId?: boolean
  assignedAt?: boolean
}

export type UserCustomLabelOmit<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = runtime.Types.Extensions.GetOmit<"id" | "userId" | "labelId" | "assignedAt", ExtArgs["result"]["userCustomLabel"]>
export type UserCustomLabelInclude<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  user?: boolean | Prisma.UserDefaultArgs<ExtArgs>
  label?: boolean | Prisma.CustomLabelDefaultArgs<ExtArgs>
}
export type UserCustomLabelIncludeCreateManyAndReturn<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  user?: boolean | Prisma.UserDefaultArgs<ExtArgs>
  label?: boolean | Prisma.CustomLabelDefaultArgs<ExtArgs>
}
export type UserCustomLabelIncludeUpdateManyAndReturn<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  user?: boolean | Prisma.UserDefaultArgs<ExtArgs>
  label?: boolean | Prisma.CustomLabelDefaultArgs<ExtArgs>
}

export type $UserCustomLabelPayload<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  name: "UserCustomLabel"
  objects: {
    user: Prisma.$UserPayload<ExtArgs>
    label: Prisma.$CustomLabelPayload<ExtArgs>
  }
  scalars: runtime.Types.Extensions.GetPayloadResult<{
    id: string
    userId: string
    labelId: string
    assignedAt: Date
  }, ExtArgs["result"]["userCustomLabel"]>
  composites: {}
}

export type UserCustomLabelGetPayload<S extends boolean | null | undefined | UserCustomLabelDefaultArgs> = runtime.Types.Result.GetResult<Prisma.$UserCustomLabelPayload, S>

export type UserCustomLabelCountArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> =
  Omit<UserCustomLabelFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
    select?: UserCustomLabelCountAggregateInputType | true
  }

export interface UserCustomLabelDelegate<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs, GlobalOmitOptions = {}> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserCustomLabel'], meta: { name: 'UserCustomLabel' } }
  /**
   * Find zero or one UserCustomLabel that matches the filter.
   * @param {UserCustomLabelFindUniqueArgs} args - Arguments to find a UserCustomLabel
   * @example
   * // Get one UserCustomLabel
   * const userCustomLabel = await prisma.userCustomLabel.findUnique({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   */
  findUnique<T extends UserCustomLabelFindUniqueArgs>(args: Prisma.SelectSubset<T, UserCustomLabelFindUniqueArgs<ExtArgs>>): Prisma.Prisma__UserCustomLabelClient<runtime.Types.Result.GetResult<Prisma.$UserCustomLabelPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

  /**
   * Find one UserCustomLabel that matches the filter or throw an error with `error.code='P2025'`
   * if no matches were found.
   * @param {UserCustomLabelFindUniqueOrThrowArgs} args - Arguments to find a UserCustomLabel
   * @example
   * // Get one UserCustomLabel
   * const userCustomLabel = await prisma.userCustomLabel.findUniqueOrThrow({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   */
  findUniqueOrThrow<T extends UserCustomLabelFindUniqueOrThrowArgs>(args: Prisma.SelectSubset<T, UserCustomLabelFindUniqueOrThrowArgs<ExtArgs>>): Prisma.Prisma__UserCustomLabelClient<runtime.Types.Result.GetResult<Prisma.$UserCustomLabelPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

  /**
   * Find the first UserCustomLabel that matches the filter.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {UserCustomLabelFindFirstArgs} args - Arguments to find a UserCustomLabel
   * @example
   * // Get one UserCustomLabel
   * const userCustomLabel = await prisma.userCustomLabel.findFirst({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   */
  findFirst<T extends UserCustomLabelFindFirstArgs>(args?: Prisma.SelectSubset<T, UserCustomLabelFindFirstArgs<ExtArgs>>): Prisma.Prisma__UserCustomLabelClient<runtime.Types.Result.GetResult<Prisma.$UserCustomLabelPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

  /**
   * Find the first UserCustomLabel that matches the filter or
   * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {UserCustomLabelFindFirstOrThrowArgs} args - Arguments to find a UserCustomLabel
   * @example
   * // Get one UserCustomLabel
   * const userCustomLabel = await prisma.userCustomLabel.findFirstOrThrow({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   */
  findFirstOrThrow<T extends UserCustomLabelFindFirstOrThrowArgs>(args?: Prisma.SelectSubset<T, UserCustomLabelFindFirstOrThrowArgs<ExtArgs>>): Prisma.Prisma__UserCustomLabelClient<runtime.Types.Result.GetResult<Prisma.$UserCustomLabelPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

  /**
   * Find zero or more UserCustomLabels that matches the filter.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {UserCustomLabelFindManyArgs} args - Arguments to filter and select certain fields only.
   * @example
   * // Get all UserCustomLabels
   * const userCustomLabels = await prisma.userCustomLabel.findMany()
   * 
   * // Get first 10 UserCustomLabels
   * const userCustomLabels = await prisma.userCustomLabel.findMany({ take: 10 })
   * 
   * // Only select the `id`
   * const userCustomLabelWithIdOnly = await prisma.userCustomLabel.findMany({ select: { id: true } })
   * 
   */
  findMany<T extends UserCustomLabelFindManyArgs>(args?: Prisma.SelectSubset<T, UserCustomLabelFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<runtime.Types.Result.GetResult<Prisma.$UserCustomLabelPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

  /**
   * Create a UserCustomLabel.
   * @param {UserCustomLabelCreateArgs} args - Arguments to create a UserCustomLabel.
   * @example
   * // Create one UserCustomLabel
   * const UserCustomLabel = await prisma.userCustomLabel.create({
   *   data: {
   *     // ... data to create a UserCustomLabel
   *   }
   * })
   * 
   */
  create<T extends UserCustomLabelCreateArgs>(args: Prisma.SelectSubset<T, UserCustomLabelCreateArgs<ExtArgs>>): Prisma.Prisma__UserCustomLabelClient<runtime.Types.Result.GetResult<Prisma.$UserCustomLabelPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

  /**
   * Create many UserCustomLabels.
   * @param {UserCustomLabelCreateManyArgs} args - Arguments to create many UserCustomLabels.
   * @example
   * // Create many UserCustomLabels
   * const userCustomLabel = await prisma.userCustomLabel.createMany({
   *   data: [
   *     // ... provide data here
   *   ]
   * })
   *     
   */
  createMany<T extends UserCustomLabelCreateManyArgs>(args?: Prisma.SelectSubset<T, UserCustomLabelCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<Prisma.BatchPayload>

  /**
   * Create many UserCustomLabels and returns the data saved in the database.
   * @param {UserCustomLabelCreateManyAndReturnArgs} args - Arguments to create many UserCustomLabels.
   * @example
   * // Create many UserCustomLabels
   * const userCustomLabel = await prisma.userCustomLabel.createManyAndReturn({
   *   data: [
   *     // ... provide data here
   *   ]
   * })
   * 
   * // Create many UserCustomLabels and only return the `id`
   * const userCustomLabelWithIdOnly = await prisma.userCustomLabel.createManyAndReturn({
   *   select: { id: true },
   *   data: [
   *     // ... provide data here
   *   ]
   * })
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * 
   */
  createManyAndReturn<T extends UserCustomLabelCreateManyAndReturnArgs>(args?: Prisma.SelectSubset<T, UserCustomLabelCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<runtime.Types.Result.GetResult<Prisma.$UserCustomLabelPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

  /**
   * Delete a UserCustomLabel.
   * @param {UserCustomLabelDeleteArgs} args - Arguments to delete one UserCustomLabel.
   * @example
   * // Delete one UserCustomLabel
   * const UserCustomLabel = await prisma.userCustomLabel.delete({
   *   where: {
   *     // ... filter to delete one UserCustomLabel
   *   }
   * })
   * 
   */
  delete<T extends UserCustomLabelDeleteArgs>(args: Prisma.SelectSubset<T, UserCustomLabelDeleteArgs<ExtArgs>>): Prisma.Prisma__UserCustomLabelClient<runtime.Types.Result.GetResult<Prisma.$UserCustomLabelPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

  /**
   * Update one UserCustomLabel.
   * @param {UserCustomLabelUpdateArgs} args - Arguments to update one UserCustomLabel.
   * @example
   * // Update one UserCustomLabel
   * const userCustomLabel = await prisma.userCustomLabel.update({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   * 
   */
  update<T extends UserCustomLabelUpdateArgs>(args: Prisma.SelectSubset<T, UserCustomLabelUpdateArgs<ExtArgs>>): Prisma.Prisma__UserCustomLabelClient<runtime.Types.Result.GetResult<Prisma.$UserCustomLabelPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

  /**
   * Delete zero or more UserCustomLabels.
   * @param {UserCustomLabelDeleteManyArgs} args - Arguments to filter UserCustomLabels to delete.
   * @example
   * // Delete a few UserCustomLabels
   * const { count } = await prisma.userCustomLabel.deleteMany({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   * 
   */
  deleteMany<T extends UserCustomLabelDeleteManyArgs>(args?: Prisma.SelectSubset<T, UserCustomLabelDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<Prisma.BatchPayload>

  /**
   * Update zero or more UserCustomLabels.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {UserCustomLabelUpdateManyArgs} args - Arguments to update one or more rows.
   * @example
   * // Update many UserCustomLabels
   * const userCustomLabel = await prisma.userCustomLabel.updateMany({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   * 
   */
  updateMany<T extends UserCustomLabelUpdateManyArgs>(args: Prisma.SelectSubset<T, UserCustomLabelUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<Prisma.BatchPayload>

  /**
   * Update zero or more UserCustomLabels and returns the data updated in the database.
   * @param {UserCustomLabelUpdateManyAndReturnArgs} args - Arguments to update many UserCustomLabels.
   * @example
   * // Update many UserCustomLabels
   * const userCustomLabel = await prisma.userCustomLabel.updateManyAndReturn({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: [
   *     // ... provide data here
   *   ]
   * })
   * 
   * // Update zero or more UserCustomLabels and only return the `id`
   * const userCustomLabelWithIdOnly = await prisma.userCustomLabel.updateManyAndReturn({
   *   select: { id: true },
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: [
   *     // ... provide data here
   *   ]
   * })
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * 
   */
  updateManyAndReturn<T extends UserCustomLabelUpdateManyAndReturnArgs>(args: Prisma.SelectSubset<T, UserCustomLabelUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<runtime.Types.Result.GetResult<Prisma.$UserCustomLabelPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

  /**
   * Create or update one UserCustomLabel.
   * @param {UserCustomLabelUpsertArgs} args - Arguments to update or create a UserCustomLabel.
   * @example
   * // Update or create a UserCustomLabel
   * const userCustomLabel = await prisma.userCustomLabel.upsert({
   *   create: {
   *     // ... data to create a UserCustomLabel
   *   },
   *   update: {
   *     // ... in case it already exists, update
   *   },
   *   where: {
   *     // ... the filter for the UserCustomLabel we want to update
   *   }
   * })
   */
  upsert<T extends UserCustomLabelUpsertArgs>(args: Prisma.SelectSubset<T, UserCustomLabelUpsertArgs<ExtArgs>>): Prisma.Prisma__UserCustomLabelClient<runtime.Types.Result.GetResult<Prisma.$UserCustomLabelPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


  /**
   * Count the number of UserCustomLabels.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {UserCustomLabelCountArgs} args - Arguments to filter UserCustomLabels to count.
   * @example
   * // Count the number of UserCustomLabels
   * const count = await prisma.userCustomLabel.count({
   *   where: {
   *     // ... the filter for the UserCustomLabels we want to count
   *   }
   * })
  **/
  count<T extends UserCustomLabelCountArgs>(
    args?: Prisma.Subset<T, UserCustomLabelCountArgs>,
  ): Prisma.PrismaPromise<
    T extends runtime.Types.Utils.Record<'select', any>
      ? T['select'] extends true
        ? number
        : Prisma.GetScalarType<T['select'], UserCustomLabelCountAggregateOutputType>
      : number
  >

  /**
   * Allows you to perform aggregations operations on a UserCustomLabel.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {UserCustomLabelAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
   * @example
   * // Ordered by age ascending
   * // Where email contains prisma.io
   * // Limited to the 10 users
   * const aggregations = await prisma.user.aggregate({
   *   _avg: {
   *     age: true,
   *   },
   *   where: {
   *     email: {
   *       contains: "prisma.io",
   *     },
   *   },
   *   orderBy: {
   *     age: "asc",
   *   },
   *   take: 10,
   * })
  **/
  aggregate<T extends UserCustomLabelAggregateArgs>(args: Prisma.Subset<T, UserCustomLabelAggregateArgs>): Prisma.PrismaPromise<GetUserCustomLabelAggregateType<T>>

  /**
   * Group by UserCustomLabel.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {UserCustomLabelGroupByArgs} args - Group by arguments.
   * @example
   * // Group by city, order by createdAt, get count
   * const result = await prisma.user.groupBy({
   *   by: ['city', 'createdAt'],
   *   orderBy: {
   *     createdAt: true
   *   },
   *   _count: {
   *     _all: true
   *   },
   * })
   * 
  **/
  groupBy<
    T extends UserCustomLabelGroupByArgs,
    HasSelectOrTake extends Prisma.Or<
      Prisma.Extends<'skip', Prisma.Keys<T>>,
      Prisma.Extends<'take', Prisma.Keys<T>>
    >,
    OrderByArg extends Prisma.True extends HasSelectOrTake
      ? { orderBy: UserCustomLabelGroupByArgs['orderBy'] }
      : { orderBy?: UserCustomLabelGroupByArgs['orderBy'] },
    OrderFields extends Prisma.ExcludeUnderscoreKeys<Prisma.Keys<Prisma.MaybeTupleToUnion<T['orderBy']>>>,
    ByFields extends Prisma.MaybeTupleToUnion<T['by']>,
    ByValid extends Prisma.Has<ByFields, OrderFields>,
    HavingFields extends Prisma.GetHavingFields<T['having']>,
    HavingValid extends Prisma.Has<ByFields, HavingFields>,
    ByEmpty extends T['by'] extends never[] ? Prisma.True : Prisma.False,
    InputErrors extends ByEmpty extends Prisma.True
    ? `Error: "by" must not be empty.`
    : HavingValid extends Prisma.False
    ? {
        [P in HavingFields]: P extends ByFields
          ? never
          : P extends string
          ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
          : [
              Error,
              'Field ',
              P,
              ` in "having" needs to be provided in "by"`,
            ]
      }[HavingFields]
    : 'take' extends Prisma.Keys<T>
    ? 'orderBy' extends Prisma.Keys<T>
      ? ByValid extends Prisma.True
        ? {}
        : {
            [P in OrderFields]: P extends ByFields
              ? never
              : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
          }[OrderFields]
      : 'Error: If you provide "take", you also need to provide "orderBy"'
    : 'skip' extends Prisma.Keys<T>
    ? 'orderBy' extends Prisma.Keys<T>
      ? ByValid extends Prisma.True
        ? {}
        : {
            [P in OrderFields]: P extends ByFields
              ? never
              : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
          }[OrderFields]
      : 'Error: If you provide "skip", you also need to provide "orderBy"'
    : ByValid extends Prisma.True
    ? {}
    : {
        [P in OrderFields]: P extends ByFields
          ? never
          : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
      }[OrderFields]
  >(args: Prisma.SubsetIntersection<T, UserCustomLabelGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserCustomLabelGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
/**
 * Fields of the UserCustomLabel model
 */
readonly fields: UserCustomLabelFieldRefs;
}

/**
 * The delegate class that acts as a "Promise-like" for UserCustomLabel.
 * Why is this prefixed with `Prisma__`?
 * Because we want to prevent naming conflicts as mentioned in
 * https://github.com/prisma/prisma-client-js/issues/707
 */
export interface Prisma__UserCustomLabelClient<T, Null = never, ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
  readonly [Symbol.toStringTag]: "PrismaPromise"
  user<T extends Prisma.UserDefaultArgs<ExtArgs> = {}>(args?: Prisma.Subset<T, Prisma.UserDefaultArgs<ExtArgs>>): Prisma.Prisma__UserClient<runtime.Types.Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
  label<T extends Prisma.CustomLabelDefaultArgs<ExtArgs> = {}>(args?: Prisma.Subset<T, Prisma.CustomLabelDefaultArgs<ExtArgs>>): Prisma.Prisma__CustomLabelClient<runtime.Types.Result.GetResult<Prisma.$CustomLabelPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
  /**
   * Attaches callbacks for the resolution and/or rejection of the Promise.
   * @param onfulfilled The callback to execute when the Promise is resolved.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of which ever callback is executed.
   */
  then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): runtime.Types.Utils.JsPromise<TResult1 | TResult2>
  /**
   * Attaches a callback for only the rejection of the Promise.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of the callback.
   */
  catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): runtime.Types.Utils.JsPromise<T | TResult>
  /**
   * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
   * resolved value cannot be modified from the callback.
   * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
   * @returns A Promise for the completion of the callback.
   */
  finally(onfinally?: (() => void) | undefined | null): runtime.Types.Utils.JsPromise<T>
}




/**
 * Fields of the UserCustomLabel model
 */
export interface UserCustomLabelFieldRefs {
  readonly id: Prisma.FieldRef<"UserCustomLabel", 'String'>
  readonly userId: Prisma.FieldRef<"UserCustomLabel", 'String'>
  readonly labelId: Prisma.FieldRef<"UserCustomLabel", 'String'>
  readonly assignedAt: Prisma.FieldRef<"UserCustomLabel", 'DateTime'>
}
    

// Custom InputTypes
/**
 * UserCustomLabel findUnique
 */
export type UserCustomLabelFindUniqueArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the UserCustomLabel
   */
  select?: Prisma.UserCustomLabelSelect<ExtArgs> | null
  /**
   * Omit specific fields from the UserCustomLabel
   */
  omit?: Prisma.UserCustomLabelOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.UserCustomLabelInclude<ExtArgs> | null
  /**
   * Filter, which UserCustomLabel to fetch.
   */
  where: Prisma.UserCustomLabelWhereUniqueInput
}

/**
 * UserCustomLabel findUniqueOrThrow
 */
export type UserCustomLabelFindUniqueOrThrowArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the UserCustomLabel
   */
  select?: Prisma.UserCustomLabelSelect<ExtArgs> | null
  /**
   * Omit specific fields from the UserCustomLabel
   */
  omit?: Prisma.UserCustomLabelOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.UserCustomLabelInclude<ExtArgs> | null
  /**
   * Filter, which UserCustomLabel to fetch.
   */
  where: Prisma.UserCustomLabelWhereUniqueInput
}

/**
 * UserCustomLabel findFirst
 */
export type UserCustomLabelFindFirstArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the UserCustomLabel
   */
  select?: Prisma.UserCustomLabelSelect<ExtArgs> | null
  /**
   * Omit specific fields from the UserCustomLabel
   */
  omit?: Prisma.UserCustomLabelOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.UserCustomLabelInclude<ExtArgs> | null
  /**
   * Filter, which UserCustomLabel to fetch.
   */
  where?: Prisma.UserCustomLabelWhereInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
   * 
   * Determine the order of UserCustomLabels to fetch.
   */
  orderBy?: Prisma.UserCustomLabelOrderByWithRelationInput | Prisma.UserCustomLabelOrderByWithRelationInput[]
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
   * 
   * Sets the position for searching for UserCustomLabels.
   */
  cursor?: Prisma.UserCustomLabelWhereUniqueInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Take `Â±n` UserCustomLabels from the position of the cursor.
   */
  take?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Skip the first `n` UserCustomLabels.
   */
  skip?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
   * 
   * Filter by unique combinations of UserCustomLabels.
   */
  distinct?: Prisma.UserCustomLabelScalarFieldEnum | Prisma.UserCustomLabelScalarFieldEnum[]
}

/**
 * UserCustomLabel findFirstOrThrow
 */
export type UserCustomLabelFindFirstOrThrowArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the UserCustomLabel
   */
  select?: Prisma.UserCustomLabelSelect<ExtArgs> | null
  /**
   * Omit specific fields from the UserCustomLabel
   */
  omit?: Prisma.UserCustomLabelOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.UserCustomLabelInclude<ExtArgs> | null
  /**
   * Filter, which UserCustomLabel to fetch.
   */
  where?: Prisma.UserCustomLabelWhereInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
   * 
   * Determine the order of UserCustomLabels to fetch.
   */
  orderBy?: Prisma.UserCustomLabelOrderByWithRelationInput | Prisma.UserCustomLabelOrderByWithRelationInput[]
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
   * 
   * Sets the position for searching for UserCustomLabels.
   */
  cursor?: Prisma.UserCustomLabelWhereUniqueInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Take `Â±n` UserCustomLabels from the position of the cursor.
   */
  take?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Skip the first `n` UserCustomLabels.
   */
  skip?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
   * 
   * Filter by unique combinations of UserCustomLabels.
   */
  distinct?: Prisma.UserCustomLabelScalarFieldEnum | Prisma.UserCustomLabelScalarFieldEnum[]
}

/**
 * UserCustomLabel findMany
 */
export type UserCustomLabelFindManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the UserCustomLabel
   */
  select?: Prisma.UserCustomLabelSelect<ExtArgs> | null
  /**
   * Omit specific fields from the UserCustomLabel
   */
  omit?: Prisma.UserCustomLabelOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.UserCustomLabelInclude<ExtArgs> | null
  /**
   * Filter, which UserCustomLabels to fetch.
   */
  where?: Prisma.UserCustomLabelWhereInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
   * 
   * Determine the order of UserCustomLabels to fetch.
   */
  orderBy?: Prisma.UserCustomLabelOrderByWithRelationInput | Prisma.UserCustomLabelOrderByWithRelationInput[]
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
   * 
   * Sets the position for listing UserCustomLabels.
   */
  cursor?: Prisma.UserCustomLabelWhereUniqueInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Take `Â±n` UserCustomLabels from the position of the cursor.
   */
  take?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Skip the first `n` UserCustomLabels.
   */
  skip?: number
  distinct?: Prisma.UserCustomLabelScalarFieldEnum | Prisma.UserCustomLabelScalarFieldEnum[]
}

/**
 * UserCustomLabel create
 */
export type UserCustomLabelCreateArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the UserCustomLabel
   */
  select?: Prisma.UserCustomLabelSelect<ExtArgs> | null
  /**
   * Omit specific fields from the UserCustomLabel
   */
  omit?: Prisma.UserCustomLabelOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.UserCustomLabelInclude<ExtArgs> | null
  /**
   * The data needed to create a UserCustomLabel.
   */
  data: Prisma.XOR<Prisma.UserCustomLabelCreateInput, Prisma.UserCustomLabelUncheckedCreateInput>
}

/**
 * UserCustomLabel createMany
 */
export type UserCustomLabelCreateManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * The data used to create many UserCustomLabels.
   */
  data: Prisma.UserCustomLabelCreateManyInput | Prisma.UserCustomLabelCreateManyInput[]
  skipDuplicates?: boolean
}

/**
 * UserCustomLabel createManyAndReturn
 */
export type UserCustomLabelCreateManyAndReturnArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the UserCustomLabel
   */
  select?: Prisma.UserCustomLabelSelectCreateManyAndReturn<ExtArgs> | null
  /**
   * Omit specific fields from the UserCustomLabel
   */
  omit?: Prisma.UserCustomLabelOmit<ExtArgs> | null
  /**
   * The data used to create many UserCustomLabels.
   */
  data: Prisma.UserCustomLabelCreateManyInput | Prisma.UserCustomLabelCreateManyInput[]
  skipDuplicates?: boolean
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.UserCustomLabelIncludeCreateManyAndReturn<ExtArgs> | null
}

/**
 * UserCustomLabel update
 */
export type UserCustomLabelUpdateArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the UserCustomLabel
   */
  select?: Prisma.UserCustomLabelSelect<ExtArgs> | null
  /**
   * Omit specific fields from the UserCustomLabel
   */
  omit?: Prisma.UserCustomLabelOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.UserCustomLabelInclude<ExtArgs> | null
  /**
   * The data needed to update a UserCustomLabel.
   */
  data: Prisma.XOR<Prisma.UserCustomLabelUpdateInput, Prisma.UserCustomLabelUncheckedUpdateInput>
  /**
   * Choose, which UserCustomLabel to update.
   */
  where: Prisma.UserCustomLabelWhereUniqueInput
}

/**
 * UserCustomLabel updateMany
 */
export type UserCustomLabelUpdateManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * The data used to update UserCustomLabels.
   */
  data: Prisma.XOR<Prisma.UserCustomLabelUpdateManyMutationInput, Prisma.UserCustomLabelUncheckedUpdateManyInput>
  /**
   * Filter which UserCustomLabels to update
   */
  where?: Prisma.UserCustomLabelWhereInput
  /**
   * Limit how many UserCustomLabels to update.
   */
  limit?: number
}

/**
 * UserCustomLabel updateManyAndReturn
 */
export type UserCustomLabelUpdateManyAndReturnArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the UserCustomLabel
   */
  select?: Prisma.UserCustomLabelSelectUpdateManyAndReturn<ExtArgs> | null
  /**
   * Omit specific fields from the UserCustomLabel
   */
  omit?: Prisma.UserCustomLabelOmit<ExtArgs> | null
  /**
   * The data used to update UserCustomLabels.
   */
  data: Prisma.XOR<Prisma.UserCustomLabelUpdateManyMutationInput, Prisma.UserCustomLabelUncheckedUpdateManyInput>
  /**
   * Filter which UserCustomLabels to update
   */
  where?: Prisma.UserCustomLabelWhereInput
  /**
   * Limit how many UserCustomLabels to update.
   */
  limit?: number
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.UserCustomLabelIncludeUpdateManyAndReturn<ExtArgs> | null
}

/**
 * UserCustomLabel upsert
 */
export type UserCustomLabelUpsertArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the UserCustomLabel
   */
  select?: Prisma.UserCustomLabelSelect<ExtArgs> | null
  /**
   * Omit specific fields from the UserCustomLabel
   */
  omit?: Prisma.UserCustomLabelOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.UserCustomLabelInclude<ExtArgs> | null
  /**
   * The filter to search for the UserCustomLabel to update in case it exists.
   */
  where: Prisma.UserCustomLabelWhereUniqueInput
  /**
   * In case the UserCustomLabel found by the `where` argument doesn't exist, create a new UserCustomLabel with this data.
   */
  create: Prisma.XOR<Prisma.UserCustomLabelCreateInput, Prisma.UserCustomLabelUncheckedCreateInput>
  /**
   * In case the UserCustomLabel was found with the provided `where` argument, update it with this data.
   */
  update: Prisma.XOR<Prisma.UserCustomLabelUpdateInput, Prisma.UserCustomLabelUncheckedUpdateInput>
}

/**
 * UserCustomLabel delete
 */
export type UserCustomLabelDeleteArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the UserCustomLabel
   */
  select?: Prisma.UserCustomLabelSelect<ExtArgs> | null
  /**
   * Omit specific fields from the UserCustomLabel
   */
  omit?: Prisma.UserCustomLabelOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.UserCustomLabelInclude<ExtArgs> | null
  /**
   * Filter which UserCustomLabel to delete.
   */
  where: Prisma.UserCustomLabelWhereUniqueInput
}

/**
 * UserCustomLabel deleteMany
 */
export type UserCustomLabelDeleteManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Filter which UserCustomLabels to delete
   */
  where?: Prisma.UserCustomLabelWhereInput
  /**
   * Limit how many UserCustomLabels to delete.
   */
  limit?: number
}

/**
 * UserCustomLabel without action
 */
export type UserCustomLabelDefaultArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the UserCustomLabel
   */
  select?: Prisma.UserCustomLabelSelect<ExtArgs> | null
  /**
   * Omit specific fields from the UserCustomLabel
   */
  omit?: Prisma.UserCustomLabelOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.UserCustomLabelInclude<ExtArgs> | null
}
